-- Group-based Real-time Chat System
-- Based on: https://github.com/shwosner/realtime-chat-supabase-react

-- Create groups table
CREATE TABLE IF NOT EXISTS groups (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  group_id VARCHAR(50) UNIQUE NOT NULL, -- Human-readable group ID like "adventure-squad-2025"
  group_name VARCHAR(100) NOT NULL,
  password_hash VARCHAR(255) NOT NULL, -- Store hashed password
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMP DEFAULT NOW(),
  is_active BOOLEAN DEFAULT TRUE
);

-- Create group_messages table 
CREATE TABLE IF NOT EXISTS group_messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  group_id VARCHAR(50) NOT NULL REFERENCES groups(group_id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id),
  username VARCHAR NOT NULL,
  message_text TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Create group_members table for tracking who's in which group
CREATE TABLE IF NOT EXISTS group_members (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  group_id VARCHAR(50) NOT NULL REFERENCES groups(group_id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id),
  username VARCHAR NOT NULL,
  joined_at TIMESTAMP DEFAULT NOW(),
  is_active BOOLEAN DEFAULT TRUE,
  UNIQUE(group_id, user_id)
);

-- Enable RLS (Row Level Security)
ALTER TABLE groups ENABLE ROW LEVEL SECURITY;
ALTER TABLE group_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE group_members ENABLE ROW LEVEL SECURITY;

-- RLS Policies for groups table
CREATE POLICY "Groups are viewable by members" ON groups
  FOR SELECT USING (
    group_id IN (
      SELECT group_id FROM group_members 
      WHERE user_id = auth.uid() AND is_active = TRUE
    )
  );

CREATE POLICY "Authenticated users can create groups" ON groups
  FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- RLS Policies for group_messages table  
CREATE POLICY "Messages are viewable by group members" ON group_messages
  FOR SELECT USING (
    group_id IN (
      SELECT group_id FROM group_members 
      WHERE user_id = auth.uid() AND is_active = TRUE
    )
  );

CREATE POLICY "Group members can insert messages" ON group_messages
  FOR INSERT WITH CHECK (
    group_id IN (
      SELECT group_id FROM group_members 
      WHERE user_id = auth.uid() AND is_active = TRUE
    )
  );

-- RLS Policies for group_members table
CREATE POLICY "Group members can view other members" ON group_members
  FOR SELECT USING (
    group_id IN (
      SELECT group_id FROM group_members 
      WHERE user_id = auth.uid() AND is_active = TRUE
    )
  );

CREATE POLICY "Users can join groups" ON group_members
  FOR INSERT WITH CHECK (auth.role() = 'authenticated');

CREATE POLICY "Users can update their own membership" ON group_members
  FOR UPDATE USING (user_id = auth.uid());

-- Enable realtime for tables
ALTER PUBLICATION supabase_realtime ADD TABLE group_messages;
ALTER PUBLICATION supabase_realtime ADD TABLE group_members;

-- Indexes for better performance
CREATE INDEX IF NOT EXISTS idx_group_messages_group_id ON group_messages(group_id);
CREATE INDEX IF NOT EXISTS idx_group_messages_created_at ON group_messages(created_at);
CREATE INDEX IF NOT EXISTS idx_group_members_group_id ON group_members(group_id);
CREATE INDEX IF NOT EXISTS idx_group_members_user_id ON group_members(user_id);
CREATE INDEX IF NOT EXISTS idx_groups_group_id ON groups(group_id);

-- Function to generate unique group IDs
CREATE OR REPLACE FUNCTION generate_group_id()
RETURNS TEXT AS $$
DECLARE
  adjectives TEXT[] := ARRAY['epic', 'awesome', 'wild', 'crazy', 'adventure', 'travel', 'explore', 'discover', 'journey', 'roam'];
  nouns TEXT[] := ARRAY['squad', 'crew', 'gang', 'team', 'group', 'tribe', 'pack', 'band', 'club', 'society'];
  result TEXT;
  counter INTEGER := 0;
BEGIN
  LOOP
    result := adjectives[1 + (random() * array_length(adjectives, 1))::int] || '-' || 
              nouns[1 + (random() * array_length(nouns, 1))::int] || '-' || 
              (extract(year from now())::text);
    
    -- Check if this group_id already exists
    IF NOT EXISTS (SELECT 1 FROM groups WHERE group_id = result) THEN
      RETURN result;
    END IF;
    
    counter := counter + 1;
    -- Prevent infinite loop
    IF counter > 100 THEN
      result := result || '-' || (random() * 9999)::int;
      RETURN result;
    END IF;
  END LOOP;
END;
$$ LANGUAGE plpgsql;
